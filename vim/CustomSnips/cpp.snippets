global !p
def doxy_parse_func(params, rt=None):
    snip.cursor.preserve()
    lst_params = params.split(',')
    n_params = len(lst_params)
    anon_snippet_body = ''
    ind = 1
    if lst_params[0] != '':
        anon_snippet_body += '\n*'
        max_len = 0
        for param in lst_params:
            split_param = param.split(' ')
            if '=' in split_param:
                temp = split_param[split_param.index('=') - 1]
            else:
                temp = split_param[-1]
            if len(temp) > max_len:
                max_len = len(temp)
        for param in lst_params:
            str_param = '\n* @param '
            split_param = param.split(' ')
            if '=' in split_param:
                temp = split_param[split_param.index('=') - 1]
            else:
                temp = split_param[-1]
            str_param += temp
            str_param += '  ' + ' ' * (max_len - len(temp)) + '$' + str(ind)
            anon_snippet_body += str_param
            ind += 1
    else:
        snip.buffer[snip.line + 2] = re.sub('\(  \)', '()', snip.buffer[snip.line + 2])
    if rt != None and 'void' not in rt:
        anon_snippet_body += '\n*'
        anon_snippet_body += '\n* @return $' + str(ind)
    if anon_snippet_body != '':
        snip.expand_anon(anon_snippet_body)

def acc_spec_comm(snip, spec, comm_type):
    spec_stars = '*' * len(spec)
    types = comm_type[0]
    if types[0] == 'c':
        snip.rv = '/**' + spec_stars + '************************'
        snip += ' * ' + spec + ' classes/structs/types *'
        snip += ' **' + spec_stars + '***********************/'
    elif types[0] == 'f':
        snip.rv = '/**' + spec_stars + '*******************'
        snip += ' * ' + spec + ' member functions *'
        snip += ' **' + spec_stars + '******************/'
    elif types[0] == 'v':
        snip.rv = '/**' + spec_stars + '*******************'
        snip += ' * ' + spec + ' member variables *'
        snip += ' **' + spec_stars + '******************/'
    if len(types) != 1:
        snip.rv += '\n' + snip.mkline('', '')
    for i in range(1, len(types)):
        if types[i] == 'c':
            snip += '/**' + spec_stars + '************************'
            snip += ' * ' + spec + ' classes/structs/types *'
            snip += ' **' + spec_stars + '***********************/'
        elif types[i] == 'f':
            snip += '/**' + spec_stars + '*******************'
            snip += ' * ' + spec + ' member functions *'
            snip += ' **' + spec_stars + '******************/'
        elif types[i] == 'v':
            snip += '/**' + spec_stars + '*******************'
            snip += ' * ' + spec + ' member variables *'
            snip += ' **' + spec_stars + '******************/'
        if i != len(types) - 1:
            snip.rv += '\n' + snip.mkline('', '')
endglobal

post_jump "if snip.tabstop == 4: doxy_parse_func(snip.tabstops[2].current_text)"
snippet cdec "constructor declaration" b
/**
 * $1 constructor.$4
 */
${1:`!v matchstr(getline(search('class \w\+', 'bnW')), '\(class \)\@<=\w\+\([ :]\?\)\@=')`}( ${2:params} )$0
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[2].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line] = re.sub('\(  \)', '()', snip.buffer[snip.line])"
snippet cdef "constructor definition" b
${1:`!p snip.rv = snip.basename`}( ${2:params} )$0
endsnippet

snippet cls "class" b
/**
 * @class
 *   ${2:description}
 */
class ${1:`!p snip.rv = snip.basename`}
{
public:

protected:

private:

};$0
endsnippet

snippet cerr "cerr" b
std::cerr << $0 << std::endl;
endsnippet

snippet cout "cout" b
std::cout << $0 << std::endl;
endsnippet

post_jump "if snip.tabstop == 4: doxy_parse_func(snip.tabstops[2].current_text)"
snippet ddec "destructor declaration" b
/**
 * $1 destructor.$4
 */
~${1:`!v matchstr(getline(search('class \w\+', 'bnW')), '\(class \)\@<=\w\+\([ :]\?\)\@=')`}( ${2:params} )$0
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[2].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line] = re.sub('\(  \)', '()', snip.buffer[snip.line])"
snippet ddef "destructor definition" b
~${1:`!p snip.rv = snip.basename`}( ${2:params} )$0
endsnippet

snippet dox "/**" b
/**
 * $0
 */
endsnippet

snippet els "else"
else
{
    ${VISUAL}$0
}
endsnippet

snippet elsif "else if()"
else if( ${1:condition} )
{
    ${VISUAL}$0
}
endsnippet

post_jump "if snip.tabstop == 5: doxy_parse_func(snip.tabstops[3].current_text, snip.tabstops[1].current_text)"
snippet fdec "function declaration" b
/**
 * ${4:description}$5
 */
${1:return} ${2:name}( ${3:params} )$0
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[3].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line] = re.sub('\(  \)', '()', snip.buffer[snip.line])"
snippet fdef "function definition" b
${1:return} ${2:name}( ${3:params} )$0
endsnippet

snippet fh "file header" b
/**
 * @file `!p snip.rv = fn`
 * @brief ${1:brief description}
 * @author Kevin Wilson
 *
 * $Revision: $
 * $Date: $
 * $LastEditedBy: $
 *
 * $Copyright: `date '+%Y'`$
 **************************************************************************/$0
endsnippet

snippet for "for()" b
for( ${1:initialize}; ${2:condition}; ${3:increment} )
{
    ${VISUAL}$0
}
endsnippet

snippet fore "foreach" b
for( ${1:element} : ${2:list} )
{
    ${VISUAL}$0
}
endsnippet

snippet hg "header guard" b
#ifndef ${1:`!p snip.rv = re.sub('(-|(?<!^)(?=[A-Z]))', '_', snip.basename).upper() + '_H_'`}
#define $1

${VISUAL}$0

#endif  // $1
endsnippet

snippet if "if()" b
if( ${1:condition} )
{
    ${VISUAL}$0
}
endsnippet

snippet logh "log header"
/**
 * $Log: $
 **************************************************************************/$0
endsnippet

snippet ns "namespace" b
namespace ${1:name}
{
${VISUAL}$0
}  // namespace $1
endsnippet

snippet "priv([cvf]+)?" "private access" br
`!p acc_spec_comm(snip, 'Private', match.groups('cvf'))`
endsnippet

snippet "prot([cvf]+)?" "protected access" br
`!p acc_spec_comm(snip, 'Protected', match.groups('cvf'))`
endsnippet

snippet "pub([cvf]+)?" "public access" br
`!p acc_spec_comm(snip, 'Public', match.groups('cvf'))`
endsnippet

snippet stru "struct" b
/// ${2:description}
struct ${1:name}
{
};$0
endsnippet
