global !p
def make_box(width):
    stars = '*' * width
    start_line = '/**' + stars + '**'
    mid_begin = ' * '
    mid_end = ' *'
    end_line = ' **' + stars + '*/'
    return start_line, mid_begin, mid_end, end_line

def acc_spec_comm(snip, spec, comm_type):
    curr_class = vim.eval("get(b:, 'coc_current_function', '')")
    curr_class_stars = '*' * (len(curr_class) + 1)
    spec_stars = '*' * len(spec)
    types = comm_type[0]
    prolog_stars  = spec_stars + curr_class_stars
    class_spec = curr_class + ' ' + spec
    if types[0] == 't':
        snip.rv  = '/**' + prolog_stars + '********'
        snip    += ' * ' + class_spec   + ' types *'
        snip    += ' **' + prolog_stars + '*******/'
    elif types[0] == 'x':
        snip.rv  = '/**' + prolog_stars + '************'
        snip    += ' * ' + class_spec   + ' constants *'
        snip    += ' **' + prolog_stars + '***********/'
    elif types[0] == 'v':
        snip.rv  = '/**' + prolog_stars + '*******************'
        snip    += ' * ' + class_spec   + ' member variables *'
        snip    += ' **' + prolog_stars + '******************/'
    elif types[0] == 'f':
        snip.rv  = '/**' + prolog_stars + '*******************'
        snip    += ' * ' + class_spec   + ' member functions *'
        snip    += ' **' + prolog_stars + '******************/'
    elif types[0] == 'p':
        snip.rv  = '/**' + prolog_stars + '********************'
        snip    += ' * ' + class_spec   + ' virtual functions *'
        snip    += ' **' + prolog_stars + '*******************/'
    elif types[0] == 'd':
        snip.rv  = '/**' + prolog_stars + '***************************'
        snip    += ' * ' + class_spec   + ' deleted member functions *'
        snip    += ' **' + prolog_stars + '**************************/'
    if len(types) != 1:
        snip.rv += '\n' + snip.mkline('', '')
    for i in range(1, len(types)):
        if types[i] == 't':
            snip += '/**' + prolog_stars + '********'
            snip += ' * ' + class_spec   + ' types *'
            snip += ' **' + prolog_stars + '*******/'
        elif types[i] == 'x':
            snip += '/**' + prolog_stars + '************'
            snip += ' * ' + class_spec   + ' constants *'
            snip += ' **' + prolog_stars + '***********/'
        elif types[i] == 'v':
            snip += '/**' + prolog_stars + '*******************'
            snip += ' * ' + class_spec   + ' member variables *'
            snip += ' **' + prolog_stars + '******************/'
        elif types[i] == 'f':
            snip += '/**' + prolog_stars + '*******************'
            snip += ' * ' + class_spec   + ' member functions *'
            snip += ' **' + prolog_stars + '******************/'
        elif types[i] == 'p':
            snip += '/**' + prolog_stars + '********************'
            snip += ' * ' + class_spec   + ' virtual functions *'
            snip += ' **' + prolog_stars + '*******************/'
        elif types[i] == 'd':
            snip += '/**' + prolog_stars + '***************************'
            snip += ' * ' + class_spec   + ' deleted member functions *'
            snip += ' **' + prolog_stars + '**************************/'
        if i != len(types) - 1:
            snip.rv += '\n' + snip.mkline('', '')
endglobal

snippet bcm "box comment" b
`!p
box = make_box(len(t[1]))
snip.rv = box[0]
snip += box[1]
`${1:text}`!p
box = make_box(len(t[1]))
snip.rv = box[2]
snip += box[3]
`
endsnippet

snippet cls "class" b
/**
 * @class $1
 * ${2:@todo description}
 */
class ${1:name}$0
{
};
endsnippet

snippet cerr "cerr" b
std::cerr << $0;
endsnippet

snippet cout "cout" b
std::cout << $0;
endsnippet

snippet dox "doxygen comment" b
/**
 * ${1:@todo description}
 */$0
endsnippet

snippet fh "file header" b
/**
 * @file `!p snip.rv = fn`
 * @brief ${1:@todo description}
 * @author Kevin Wilson
 *
 * $Revision: $
 * $Date: $
 * $LastEditedBy: $
 *
 * $Copyright: `date '+%Y'`$
 **************************************************************************/$0
endsnippet

snippet hg "header guard" b
#ifndef ${1:`!p snip.rv = snip.basename.upper() + '_H'`}
#define $1

${VISUAL}$0

#endif  // $1
endsnippet

snippet logh "log header" b
/**
 * $Log: $
 **************************************************************************/$0
endsnippet

snippet nocm "no copy/move declarations" b
${1:name}($1 const&) = delete;
$1($1&&) = delete;
$1& operator=($1 const&) = delete;
$1& operator=($1&&) = delete;$0
endsnippet

snippet ns "namespace" b
namespace ${1:name}
{
${VISUAL}$0
}  // namespace $1
endsnippet

snippet "priv([txvfpd]+)?" "private access" br
`!p acc_spec_comm(snip, 'private', match.groups('txvfpd'))`
endsnippet

snippet "prot([txvfpd]+)?" "protected access" br
`!p acc_spec_comm(snip, 'protected', match.groups('txvfpd'))`
endsnippet

snippet "pub([txvfpd]+)?" "public access" br
`!p acc_spec_comm(snip, 'public', match.groups('txvfpd'))`
endsnippet

snippet stru "struct" b
/**
 * @class $1
 * ${2:@todo description}
 */
struct ${1:name}$0
{
};
endsnippet
