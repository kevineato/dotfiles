global !p
def doxy_parse_func(params, rt=None):
    snip.cursor.preserve()
    lst_params = params.split(',')
    n_params = len(lst_params)
    anon_snippet_body = ''
    ind = 1
    if lst_params[0] != '':
        anon_snippet_body += '\n*'
        max_len = 0
        for param in lst_params:
            split_param = param.split(' ')
            if '=' in split_param:
                temp = split_param[split_param.index('=') - 1]
            else:
                temp = split_param[-1]
            if len(temp) > max_len:
                max_len = len(temp)
        for param in lst_params:
            str_param = '\n* @param '
            split_param = param.split(' ')
            if '=' in split_param:
                temp = split_param[split_param.index('=') - 1]
            else:
                temp = split_param[-1]
            str_param += temp
            str_param += '  ' + ' ' * (max_len - len(temp)) + '$' + str(ind)
            anon_snippet_body += str_param
            ind += 1
    else:
        snip.buffer[snip.line + 2] = re.sub('\(  \)', '()', snip.buffer[snip.line + 2])
    if rt != None and 'void' not in rt:
        anon_snippet_body += '\n*'
        anon_snippet_body += '\n* @return $' + str(ind)
    if anon_snippet_body != '':
        snip.expand_anon(anon_snippet_body)

def acc_spec_comm(snip, spec, comm_type):
    curr_class = vim.eval("get(b:, 'coc_current_function', '')")
    curr_class_stars = '*' * (len(curr_class) + 1)
    spec_stars = '*' * len(spec)
    types = comm_type[0]
    prolog_stars  = spec_stars + curr_class_stars
    class_spec = curr_class + ' ' + spec
    if types[0] == 't':
        snip.rv  = '/**' + prolog_stars + '********'
        snip    += ' * ' + class_spec   + ' types *'
        snip    += ' **' + prolog_stars + '*******/'
    elif types[0] == 'c':
        snip.rv  = '/**' + prolog_stars + '******************'
        snip    += ' * ' + class_spec   + ' classes/structs *'
        snip    += ' **' + prolog_stars + '*****************/'
    elif types[0] == 'v':
        snip.rv  = '/**' + prolog_stars + '*******************'
        snip    += ' * ' + class_spec   + ' member variables *'
        snip    += ' **' + prolog_stars + '******************/'
    elif types[0] == 'f':
        snip.rv  = '/**' + prolog_stars + '*******************'
        snip    += ' * ' + class_spec   + ' member functions *'
        snip    += ' **' + prolog_stars + '******************/'
    elif types[0] == 'p':
        snip.rv  = '/**' + prolog_stars + '********************'
        snip    += ' * ' + class_spec   + ' virtual functions *'
        snip    += ' **' + prolog_stars + '*******************/'
    if len(types) != 1:
        snip.rv += '\n' + snip.mkline('', '')
    for i in range(1, len(types)):
        if types[i] == 't':
            snip += '/**' + prolog_stars + '********'
            snip += ' * ' + class_spec   + ' types *'
            snip += ' **' + prolog_stars + '*******/'
        elif types[i] == 'c':
            snip += '/**' + prolog_stars + '************************'
            snip += ' * ' + class_spec   + ' classes/structs/types *'
            snip += ' **' + prolog_stars + '***********************/'
        elif types[i] == 'v':
            snip += '/**' + prolog_stars + '*******************'
            snip += ' * ' + class_spec   + ' member variables *'
            snip += ' **' + prolog_stars + '******************/'
        elif types[i] == 'f':
            snip += '/**' + prolog_stars + '*******************'
            snip += ' * ' + class_spec   + ' member functions *'
            snip += ' **' + prolog_stars + '******************/'
        elif types[0] == 'p':
            snip += '/**' + prolog_stars + '********************'
            snip += ' * ' + class_spec   + ' virtual functions *'
            snip += ' **' + prolog_stars + '*******************/'
        if i != len(types) - 1:
            snip.rv += '\n' + snip.mkline('', '')
endglobal

post_jump "if snip.tabstop == 4: doxy_parse_func(snip.tabstops[2].current_text)"
snippet cdec "constructor declaration" b
/**
 * $1 constructor.$4
 */
${1:`!v matchstr(getline(search('class \w\+', 'bnW')), '\(class \)\@<=\w\+\([ :]\?\)\@=')`}( ${2:params} )$0
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[2].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line] = re.sub('\(  \)', '()', snip.buffer[snip.line])"
snippet cdef "constructor definition" b
${1:`!p snip.rv = snip.basename`}( ${2:params} )$0
endsnippet

snippet cls "class" b
/**
 * @class
 *   ${2:description}
 */
class ${1:`!p snip.rv = snip.basename`}
{
};$0
endsnippet

snippet cerr "cerr" b
std::cerr << $0 << std::endl;
endsnippet

snippet cout "cout" b
std::cout << $0 << std::endl;
endsnippet

post_jump "if snip.tabstop == 4: doxy_parse_func(snip.tabstops[2].current_text)"
snippet ddec "destructor declaration" b
/**
 * $1 destructor.$4
 */
~${1:`!v matchstr(getline(search('class \w\+', 'bnW')), '\(class \)\@<=\w\+\([ :]\?\)\@=')`}( ${2:params} )$0
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[2].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line] = re.sub('\(  \)', '()', snip.buffer[snip.line])"
snippet ddef "destructor definition" b
~${1:`!p snip.rv = snip.basename`}( ${2:params} )$0
endsnippet

snippet dox "/**" b
/**
 * $0
 */
endsnippet

snippet els "else"
else
{
    ${VISUAL}$0
}
endsnippet

snippet elsif "else if()"
else if( ${1:condition} )
{
    ${VISUAL}$0
}
endsnippet

post_jump "if snip.tabstop == 5: doxy_parse_func(snip.tabstops[3].current_text, snip.tabstops[1].current_text)"
snippet fdec "function declaration" b
/**
 * ${4:description}$5
 */
${1:return} ${2:name}( ${3:params} )$0;
endsnippet

post_jump "if snip.tabstop == 0 and snip.tabstops[3].current_text == '': snip.cursor.preserve(); snip.buffer[snip.line - 1] = re.sub('\(  \)', '()', snip.buffer[snip.line - 1])"
snippet fdef "function definition" b
${1:return} ${2:name}( ${3:params} )$4
{$0
}
endsnippet

snippet fh "file header" b
/**
 * @file `!p snip.rv = fn`
 * @brief ${1:brief description}
 * @author Kevin Wilson
 *
 * $Revision: $
 * $Date: $
 * $LastEditedBy: $
 *
 * $Copyright: `date '+%Y'`$
 **************************************************************************/$0
endsnippet

snippet for "for()" b
for( ${1:initialize}; ${2:condition}; ${3:increment} )
{
    ${VISUAL}$0
}
endsnippet

snippet fore "foreach" b
for( ${1:element} : ${2:list} )
{
    ${VISUAL}$0
}
endsnippet

snippet hg "header guard" b
#ifndef ${1:`!p snip.rv = re.sub('(-|(?<!^)(?=[A-Z]))', '_', snip.basename).upper() + '_H_'`}
#define $1

${VISUAL}$0

#endif  // $1
endsnippet

snippet if "if()" b
if( ${1:condition} )
{
    ${VISUAL}$0
}
endsnippet

snippet itdef "iterator class" b
using value_type = value_type;
using difference_type = std::ptrdiff_t;
using pointer_const = const value_type*;
using pointer = value_type*;
using const_reference = const value_type&;
using reference = value_type&;
using size_type = size_type;

/// Implementation of a random access iterator.
struct iterator
{
    /*************************
     * iterator public types *
     ************************/

    using iterator_category = std::random_access_iterator_tag;
    using value_type = value_type;
    using difference_type = difference_type;
    using pointer = pointer;
    using reference = reference;

    /************************************
     * iterator public member variables *
     ***********************************/

    pointer m_pValue;

    /************************************
     * iterator public member functions *
     ***********************************/

    /// iterator constructor.
    iterator( pointer pValue = nullptr ) : m_pValue( pValue )
    {
    }

    /// Dereference operator.
    reference operator*() const
    {
        return *m_pValue;
    }

    /// Arrow dereference operator.
    pointer operator->() const
    {
        return &( operator*() );
    }

    /// Assignment operator.
    iterator& operator=( const iterator& other )
    {
        if( this == &other )
            return *this;

        m_pValue = other.m_pValue;
        return *this;
    }

    /// Prefix increment operator.
    iterator& operator++()
    {
        /* prefix ++ impl */
        return *this;
    }

    /// Prefix decrement operator.
    iterator& operator--()
    {
        /* prefix -- impl */
        return *this;
    }

    /// Postfix increment operator.
    iterator operator++( int )
    {
        iterator copyIt = *this;
        ++*this;
        return copyIt;
    }

    /// Postfix decrement operator.
    iterator operator--( int )
    {
        iterator copyIt = *this;
        --*this;
        return copyIt;
    }

    /// Equality comparison operator.
    bool operator==( const iterator& other ) const
    {
        return m_pValue == other.m_pValue;
    }

    /// Inequality comparison operator.
    bool operator!=( const iterator& other ) const
    {
        return m_pValue != other.m_pValue;
    }

    /// Less-than comparison operator.
    bool operator<( const iterator& other ) const
    {
        /* < impl */
    }

    /// Greater than comparison operator.
    bool operator>( const iterator& other ) const
    {
        return other < *this;
    }

    /// Less-than-or-equal comparison operator.
    bool operator<=( const iterator& other ) const
    {
        return !( other < *this );
    }

    /// Greater-than-or-equal comparison operator.
    bool operator>=( const iterator& other ) const
    {
        return !( *this < other );
    }

    /// Compound add difference_type and assign operator.
    iterator& operator+=( difference_type n )
    {
        if( n > 0 )
            /* += impl */
        else if( n < 0 )
            *this -= -n;

        return *this;
    }

    /// Add difference_type operator.
    iterator operator+( difference_type n ) const
    {
        return iterator( *this ) += n;
    }

    /// Compound subtract difference_type and assign operator.
    iterator& operator-=( difference_type n )
    {
        if( n > 0 )
            /* -= impl */
        else if( n < 0 )
            *this += -n;

        return *this;
    }

    /// Subtract difference_type operator.
    iterator operator-( difference_type n ) const
    {
        return iterator( *this ) -= n;
    }

    /// Subtract iterator operator.
    difference_type operator-( const iterator& other ) const
    {
        /* iterator - iterator impl */
    }

    /// Element access operator.
    reference operator[]( difference_type n ) const
    {
        return *( *this + n );
    }
};
using const_iterator = const iterator;
using reverse_iterator = std::reverse_iterator< iterator >;
using const_reverse_iterator = std::reverse_iterator< const_iterator >;
endsnippet

snippet logh "log header"
/**
 * $Log: $
 **************************************************************************/$0
endsnippet

snippet ns "namespace" b
namespace ${1:name}
{
${VISUAL}$0
}  // namespace $1
endsnippet

snippet "priv([tcvfp]+)?" "private access" br
`!p acc_spec_comm(snip, 'private', match.groups('tcvfp'))`
endsnippet

snippet "prot([tcvfp]+)?" "protected access" br
`!p acc_spec_comm(snip, 'protected', match.groups('tcvfp'))`
endsnippet

snippet "pub([tcvfp]+)?" "public access" br
`!p acc_spec_comm(snip, 'public', match.groups('tcvfp'))`
endsnippet

snippet stru "struct" b
/// ${2:description}
struct ${1:name}
{
};$0
endsnippet
