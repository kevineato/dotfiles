""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if !has('nvim')
  call plug#begin('~/.vim/plugged')
else
  call plug#begin(stdpath('data') . '/plugged')
endif
Plug 'jiangmiao/auto-pairs'
Plug 'tjdevries/coc-zsh'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'lfilho/cosco.vim'
Plug 'vim-scripts/DoxygenToolkit.vim'
Plug 'gruvbox-community/gruvbox'
Plug 'sainnhe/gruvbox-material'
" Plug 'haya14busa/is.vim'
Plug 'itchyny/lightline.vim'
Plug 'preservim/nerdcommenter'
Plug 'lotabout/skim', {'dir': '~/.skim', 'do': './install'}
Plug 'lotabout/skim.vim'
Plug 'godlygeek/tabular'
Plug 'kevineato/tagbar'
" Plug 'tbabej/taskwiki'
Plug 'kevineato/tinykeymap_vim'
Plug 'SirVer/ultisnips'
Plug 'mbbill/undotree'
Plug 'ap/vim-buftabline'
Plug 'ryanoasis/vim-devicons'
Plug 'justinmk/vim-dirvish'
Plug 'junegunn/vim-easy-align'
Plug 'easymotion/vim-easymotion'
Plug 'tpope/vim-fugitive'
Plug 'farmergreg/vim-lastplace'
Plug 'jackguo380/vim-lsp-cxx-highlight'
Plug 'terryma/vim-multiple-cursors'
Plug 'junegunn/vim-peekaboo'
Plug 'reconquest/vim-pythonx'
Plug 'tpope/vim-repeat'
Plug 'kevineato/vim-sandwich'
Plug 'mhinz/vim-signify'
Plug 'mhinz/vim-startify'
Plug 'kana/vim-textobj-user'
" Plug 'vimwiki/vimwiki'
call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

filetype plugin indent on

if !has('nvim')
  set autoindent
  set autoread
  set background=dark
  set backspace=indent,eol,start
  set belloff=all
  set complete-=i
  set cscopeverbose
  set display=lastline
  set encoding=utf-8
  set fileencoding=utf-8
  set fileencodings=utf-8
  set formatoptions+=j
  set history=10000
  set incsearch
  set langnoremap
  set laststatus=2
  set listchars="tab:> ,trail:-,nbsp+"
  set nocompatible
  set nofsync
  set nostartofline
  set nrformats=bin,hex
  set ruler
  set sessionoptions-=options
  set shortmess+=F
  set shortmess-=S
  set sidescroll=1
  set t_Co=256
  set t_ut=
  set tabpagemax=50
  set ttimeoutlen=50
  set ttyfast
  set viminfo+=!
  set wildmenu
  syntax enable
else
  set nosmarttab
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" gruvbox/gruvbox-material
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:gruvbox_material_background = 'hard'
let g:gruvbox_material_current_word = 'underline'
let g:gruvbox_material_diagnostic_line_highlight = 1
let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_invert_selection = 0
colorscheme gruvbox

set colorcolumn=80
highlight! link ColorColumn CursorLine

set breakindent
set breakindentopt=sbr
set clipboard=unnamed,unnamedplus
set cmdheight=2
set completeopt=menuone,preview,noinsert,noselect
set cursorline
set expandtab
set grepprg=rg\ --vimgrep
set helpheight=9999
set hidden
set ignorecase
set mouse=a
set mousemodel=popup
set nobackup
set nohlsearch
set noshowcmd
set noshowmode
set nowritebackup
set number relativenumber
set shiftwidth=2
set shortmess+=c
set showbreak=ï¬Œ
set signcolumn=yes
set smartcase
set tabstop=2
set termguicolors
set timeoutlen=300
set updatetime=50
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__
set wildmode=longest:full,full
set wrap

let mapleader = ','

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto-pairs
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup myautopairs
  autocmd!
  autocmd FileType c,cpp,h,hpp,java,snippets let b:AutoPairs = AutoPairsDefine({'\w\zs<': '>'})
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" coc.nvim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:coc_global_extensions = [
      \   "coc-clangd",
      \   "coc-cmake",
      \   "coc-css",
      \   "coc-explorer",
      \   "coc-html",
      \   "coc-java",
      \   "coc-json",
      \   "coc-lists",
      \   "coc-marketplace",
      \   "coc-python",
      \   "coc-sh",
      \   "coc-snippets",
      \   "coc-tabnine",
      \   "coc-tsserver",
      \   "coc-ultisnips",
      \   "coc-vimlsp",
      \   "coc-xml",
      \   "coc-yaml",
      \   "coc-yank"
      \ ]
let g:coc_snippet_next = "<C-j>"
let g:coc_snippet_prev = "<C-k>"
let g:markdown_fenced_languages = [
      \ 'vim',
      \ 'help'
      \ ]

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

command! -nargs=? Fold :call CocAction('fold', <f-args>)
command! -nargs=0 Format :call CocAction('format')

nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> <Space>qf <Plug>(coc-fix-current)
nmap <silent> <Space>v <Plug>(coc-format-selected)
nmap <Leader>rn <Plug>(coc-rename)
nnoremap <expr> <C-f> coc#util#has_float() ? coc#util#float_scroll(1) : "\<C-f>"
nnoremap <expr> <C-b> coc#util#has_float() ? coc#util#float_scroll(0) : "\<C-b>"
nnoremap <silent> <Space>c :<C-u>CocList commands<CR>
nnoremap <silent> <Space>e :<C-u>CocCommand explorer<CR>
nnoremap <silent> <Space>ef :<C-u>CocCommand explorer --reveal <C-r>=expand('%:p')<CR> <C-r>=expand('%:p:h')<CR><CR>
nnoremap <silent> <Space>E :<C-u>CocList marketplace<CR>
nnoremap <silent> <Space>f :<C-u>Format<CR>
nnoremap <silent> <Space>j :<C-u>CocNext<CR>
nnoremap <silent> <Space>k :<C-u>CocPrev<CR>
nnoremap <silent> <Space>o :<C-u>CocList -A outline<CR>
" nnoremap <silent> <Space>q :<C-u>CocList -A --normal quickfix<CR>
nnoremap <silent> <Space>r :<C-u>CocListResume<CR>
nnoremap <silent> <Space>R :<C-u>CocRestart<CR>
nnoremap <silent> <Space>s :<C-u>CocList -I -A symbols<CR>
nnoremap <silent> <Space>y :<C-u>CocList -A --normal yank<CR>
nnoremap <silent> K :call <SID>show_documentation()<CR>
omap ac <Plug>(coc-classobj-a)
omap af <Plug>(coc-funcobj-a)
omap ic <Plug>(coc-classobj-i)
omap if <Plug>(coc-funcobj-i)
vmap <silent> <Space>v <Plug>(coc-format-selected)
xmap ac <Plug>(coc-classobj-a)
xmap af <Plug>(coc-funcobj-a)
xmap ic <Plug>(coc-classobj-i)
xmap if <Plug>(coc-funcobj-i)

augroup mycocnvim
  autocmd!
  autocmd CursorHold * silent call CocActionAsync('highlight')
  autocmd CursorHoldI * silent call CocActionAsync('showSignatureHelp')
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cosco.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup mycosco
  autocmd!
  autocmd FileType c,cpp,h,hpp,java imap <silent> <Leader>; <C-o><Plug>(cosco-commaOrSemiColon)
  autocmd FileType c,cpp,h,hpp,java nmap <silent> <Leader>; <Plug>(cosco-commaOrSemiColon)
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" DoxygenToolkit.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:DoxygenToolkit_briefTag_pre = ""

function! s:shortDoxy()
  let original_startCommentTag = g:DoxygenToolkit_startCommentTag
  let original_interCommentTag = g:DoxygenToolkit_interCommentTag
  let original_endCommentTag = g:DoxygenToolkit_endCommentTag
  let original_startCommentBlock = g:DoxygenToolkit_startCommentBlock
  let original_interCommentBlock = g:DoxygenToolkit_interCommentBlock
  let original_endCommentBlock = g:DoxygenToolkit_endCommentBlock

  let g:DoxygenToolkit_startCommentTag = "/// "
  let g:DoxygenToolkit_interCommentTag = "/// "
  let g:DoxygenToolkit_endCommentTag = ""
  let g:DoxygenToolkit_startCommentBlock = "// "
  let g:DoxygenToolkit_interCommentBlock = "// "
  let g:DoxygenToolkit_endCommentBlock = ""

  execute "Dox"

  let g:DoxygenToolkit_startCommentTag = original_startCommentTag
  let g:DoxygenToolkit_interCommentTag = original_interCommentTag
  let g:DoxygenToolkit_endCommentTag = original_endCommentTag
  let g:DoxygenToolkit_startCommentBlock = original_startCommentBlock
  let g:DoxygenToolkit_interCommentBlock = original_interCommentBlock
  let g:DoxygenToolkit_endCommentBlock = original_endCommentBlock
endfunction

nnoremap <silent> <Leader>ad :<C-u>Dox<CR>
nnoremap <silent> <Leader>as :<C-u>call <SID>shortDoxy()<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" skim.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:skim_layout = { 'down': '~40%'  }

function! s:my_skim_rg_handler(lines, has_column)
  if len(a:lines) < 2
    return
  endif

  function! s:my_rg_to_qf(line, has_column)
    let parts = split(a:line, '[^:]\zs:\ze[^:]')
    let text = join(parts[(a:has_column ? 3 : 2):], ':')
    let dict = {'filename': &acd ? fnamemodify(parts[0], ':p') : parts[0], 'lnum': parts[1], 'text': text}
    if a:has_column
      let dict.col = parts[2]
    endif
    return dict
  endfunction

  let list = map(filter(a:lines[1:], 'len(v:val)'), 's:my_rg_to_qf(v:val, a:has_column)')

  if len(list) == 1
    execute 'e' list[0].filename
    call cursor([list[0].lnum, list[0].col])
    call feedkeys('zz')
    return
  endif

  call setqflist(list)
  call s:sortUniqQFList()
  execute 'CocList -A --normal quickfix'
endfunction

function! RipgrepSkim(query, args, do_curr_dir)
  let command_fmt = 'rg --pcre2 --no-heading --color=always --smart-case %s "{}" %s'
  let curr_dir = a:do_curr_dir ? expand('%:h') : '.'
  let rg_command = printf(command_fmt, a:args, curr_dir)

  let has_column = a:args =~# '--column'
  let opts = {
  \   'column': has_column,
  \   'options': [
  \     '-i', '-c', rg_command,
  \     '--ansi', '--cmd-prompt', 'rg> ',
  \     '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
  \      '--color', 'hl:4,hl+:12'
  \   ],
  \   'source': 'none'
  \ }

  if !has_column
    let opts['sink'] = 'e'
    let wrapped = s:skim_wrap('rg', opts, 'sink')
  else
    function! opts.sink(lines)
      return s:my_skim_rg_handler(a:lines, self.column)
    endfunction
    let opts['sink*'] = remove(opts, 'sink')
    let wrapped = s:skim_wrap('rg', opts, 'sink*')
  endif
  call skim#run(wrapped)
  if !empty(a:query)
    sleep 100m
    call feedkeys(a:query, 't')
  endif
endfunction

function! s:skim_wrap(name, opts, ...)
  if a:0
    let sinks = {}
    for key in split(a:1)
      let sinks[key] = remove(a:opts, key)
    endfor
  endif
  let wrapped = skim#wrap(a:name, fzf#vim#with_preview(a:opts, 'right:50%', 'alt-h'))
  if a:0
    for key in keys(sinks)
      let wrapped[key] = sinks[key]
    endfor
  endif
  return wrapped
endfunction

function! s:skim_buflist(do_mru)
  if a:do_mru
    redir => ls
    silent ls!
    redir END
    let filtered = filter(split(ls, '\n'), "v:val !~ '/tmp/\\|Tagbar\\|/\"\\|\\[Scratch]'")
    let filtered = map(filtered, "expand(substitute(v:val, '.*\"\\(.\\+\\)\".*', '\\1', ''))")
    return filter(filtered, "filereadable(glob(v:val)) && !buflisted(glob(v:val))")
  endif
  redir => ls
  silent ls
  redir END
  let filtered = map(split(ls, '\n'), "expand(substitute(v:val, '.*\"\\(.\\+\\)\".*', '\\1', ''))")
  return filter(filtered, "filereadable(glob(v:val))")
endfunction

command! Mru call skim#run(<SID>skim_wrap('mru' ,{
      \   'source': reverse(<SID>skim_buflist(1)),
      \   'options': ['--multi'],
      \   'down': '40%'
      \ }))
command! DBuffers call skim#run(<SID>skim_wrap('dBuffers', {
      \   'source': reverse(<SID>skim_buflist(0)),
      \   'sink': 'bd',
      \   'options': ['--multi'],
      \   'down': '40%'
      \ }))
command! -bang -nargs=* RG call RipgrepSkim(<q-args>, '--column --line-number', <bang>0)
command! -bang -nargs=* RGFiles call RipgrepSkim(<q-args>, '--files-with-matches', <bang>0)

nmap <Leader>y :History:<CR>
nnoremap <silent> <Leader>b :Buffers<CR>
nnoremap <silent> <Leader>B :Mru<CR>
nnoremap <silent> <Leader>db :DBuffers<CR>
nnoremap <silent> <Leader>e :SK<CR>
nnoremap <silent> <Leader>ed :SK <C-r>=expand('%:h')<CR><CR>
nnoremap <silent> <Leader>f :RG<CR>
nnoremap <silent> <Leader>fd :RG!<CR>
nnoremap <silent> <Leader>fw :RG <C-r>=expand('<cword>')<CR><CR>
nnoremap <silent> <Leader>fdw :RG! <C-r>=expand('<cword>')<CR><CR>
nnoremap <silent> <Leader>F :RGFiles<CR>
nnoremap <silent> <Leader>Fd :RGFiles!<CR>
nnoremap <silent> <Leader>Fw :RGFiles <C-r>=expand('<cword>')<CR><CR>
nnoremap <silent> <Leader>Fdw :RGFiles! <C-r>=expand('<cword>')<CR><CR>
nnoremap <silent> <Leader>l :BLines<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:is#do_default_mappings = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:lightline = {
      \   'active': {
      \     'left': [['mode', 'paste'],
      \       ['readonly', 'filename', 'modified', 'cocstatus']]
      \   },
      \   'colorscheme': 'gruvbox_material',
      \   'component': { 'cocstatus': '%{get(b:, "coc_current_function", "")}' }
      \ }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" nerdcommenter
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:NERDCustomDelimiters = {
      \   'json': { 'left': '//' }
      \ }
let g:NERDSpaceDelims = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tabular
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:align_comment()
  let save_pos = getpos('.')[1:2]
  let tab_intro = "call Tabularize('/.*\\*/l1')"
  let tab_param = "call Tabularize('/.*@param \\zs\\w\\+\\|\\*\\zs \\?/l1l2')"
  let tab_ret = "call Tabularize('/.*@return\\zs \\|\\*\\zs \\?/l0')"

  if getline('.') =~# '\s*\/\*\*'
    let c_begin = getpos('.')[1]
  else
    let c_begin = search('\/\*\*', 'bcn')
  endif

  if getline('.') =~# '\s*\*\+/'
    let c_end = getpos('.')[1]
  else
    let c_end = search('\*\/', 'cn')
  endif

  let prev_text = getline(c_begin, c_end)
  let curr_text = ['']

  while curr_text != prev_text

    let prev_text = getline(c_begin, c_end)

    if c_begin + 1 != c_end - 1
      execute (c_begin + 1) . ',' . (c_end - 1) . tab_intro
    endif
    call cursor(c_begin, save_pos[1])
    if search('@param', '', c_end)
      let p_begin = line('.')
      while search('@param', '', c_end)
      endwhile
      if search('@return', '', c_end)
        let p_end = line('.') - 1
      else
        let p_end = c_end - 1
      endif
      execute (p_begin - 1) . ',' . p_end . tab_param
    endif
    if search('@return', 'c', c_end)
      let r_begin = line('.')
      if r_begin != c_end - 1
        execute r_begin . ',' . (c_end - 1) . tab_ret
      endif
    endif

    silent execute "normal v\<Plug>(textobj-comment-multiline-a)"
    silent execute "normal \<Plug>(coc-format-selected)"
    sleep 100m

    call cursor(save_pos)

    if getline('.') =~# '\s*\/\*\*'
      let c_begin = getpos('.')[1]
    else
      let c_begin = search('\/\*\*', 'bcn')
    endif

    if getline('.') =~# '\s*\*\+/'
      let c_end = getpos('.')[1]
    else
      let c_end = search('\*\/', 'cn')
    endif

    let curr_text = getline(c_begin, c_end)
  endwhile
  " let c_begin = search('\/\*\*', 'bc')
  " normal! m<
  " let c_end = search('\*\/', 'c')
  " normal! m>gv
  " if visualmode() ==# 'v'
    " normal! V
  " endif
endfunction

augroup mytabular
  autocmd!
  autocmd FileType c,cpp,h,hpp,java nnoremap <buffer> <silent> <Leader>ac :call <SID>align_comment()<CR>
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tagbar
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:tagbar_autofocus = 1
let g:tagbar_compact = 1
let g:tagbar_ctags_bin = $HOME . '/.local/bin/ctags'
let g:tagbar_show_linenumbers = 2
let g:tagbar_sort = 0
let g:tagbar_type_cpp = {
      \   'ctagsargs': [
      \     '-f',
      \     '-',
      \     '--format=2',
      \     '--excmd=pattern',
      \     '--extras=+Fpr',
      \     '--fields=nksSaf',
      \     '--fields-C++=+{properties}{name}{captures}{template}{specialization}',
      \     '--language-force=C++',
      \     '--sort=no',
      \     '--append=no',
      \     '--kinds-C++=hdpgetncsufmv'
      \   ]
      \ }

nmap <silent> <F4> :TagbarToggle<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tinykeymap_vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:tinykeymaps_default = []
let g:tinykeymap#break_key = 113
let g:tinykeymap#conflict = 3
let g:tinykeymap#timeout = 0

if !empty(glob((has('nvim') ? stdpath('data') : '~/.vim') . '/plugged/tinykeymap_vim/plugin/tinykeymap.vim'))
  function! s:tinykeymap_multi_enter(prefix, mappings)
    if has_key(a:mappings, 'options')
      let a:mappings['options']['name'] = a:prefix
    else
      let a:mappings['options'] = { 'name': a:prefix }
    endif
    let ind = 0
    for [key, val] in items(a:mappings['startmaps'])
      let temp = deepcopy(a:mappings['options'])
      if has_key(val, 'start')
        let temp['start'] = val['start']
      endif
      if has_key(val, 'stop')
        let temp['stop'] = val['stop']
      else
        let temp['stop'] = 'mode'
      endif
      if has_key(val, 'after')
        let temp['after'] = val['after']
      endif
      call tinykeymap#EnterMap(a:prefix . ind, key, temp)
      for [m_key, m_val] in items(a:mappings['maps'])
        if type(m_val) == v:t_string
          call tinykeymap#Map(a:prefix . ind, m_key, m_val)
        elseif type(m_val) == v:t_dict
          call tinykeymap#Map(a:prefix . ind, m_key, m_val['cmd'], m_val['options'])
        endif
      endfor
      let ind += 1
    endfor
  endfunction

  " buffers
  call s:tinykeymap_multi_enter('buffers', {
        \   'startmaps': {
        \     '[b': {'start': 'bprevious'},
        \     ']b': {'start': 'bnext'}
        \   },
        \   'maps': {
        \     '[': '<count1>bprevious',
        \     ']': '<count1>bnext',
        \     'd': 'if buflisted(0) | b # | else | bp | endif | bd #'
        \   }
        \ })

  " curly
  function! SearchCurly(square, curly)
    if a:square == ']'
      silent! call search('^\s*' . a:curly . ';\?$', 'esW')
    elseif a:square == '['
      silent! call search('^\s*' . a:curly . ';\?$', 'besW')
    endif
  endfunction

  call s:tinykeymap_multi_enter('curly', {
        \   'startmaps': {
        \     '[{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("[", "{") | normal! zz'},
        \     ']{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("]", "{") | normal! zz'},
        \     '[}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("[", "}") | normal! zz'},
        \     ']}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("]", "}") | normal! zz'},
        \   },
        \   'maps': {
        \     '[': 'call SearchCurly("[", g:vimrc#last_curly)',
        \     ']': 'call SearchCurly("]", g:vimrc#last_curly)'
        \   },
        \   'options': {
        \     'after': 'normal! zz'
        \   }
        \ })

  " movement
  call tinykeymap#EnterMap('movement', '<Space>.', {'start': 'normal! zz', 'stop': 'mode', 'after': 'normal! zz'})
  call tinykeymap#Map('movement', 'd', "normal! \<C-d>")
  call tinykeymap#Map('movement', 'j', 'normal! j')
  call tinykeymap#Map('movement', 'k', 'normal! k')
  call tinykeymap#Map('movement', 'u', "normal! \<C-u>")

  " quickfix
  call s:tinykeymap_multi_enter('quickfix', {
        \   'startmaps': {
        \     '[q': {'start': 'cprevious | normal! zz'},
        \     ']q': {'start': 'cnext | normal! zz'}
        \   },
        \   'maps': {
        \     '[': '<count1>cprevious',
        \     ']': '<count1>cnext',
        \     'c': {'cmd': 'cclose', 'options': {'exit': 1}}
        \   },
        \   'options': {
        \     'after': 'normal! zz'
        \   }
        \ })
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ultisnips
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:UltiSnipsExpandTrigger = "<C-j>"
let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsJumpForwardTrigger = "<C-j>"
let g:UltiSnipsSnippetDirectories=[$HOME . '/.vim/CustomSnips']

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" undotree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:undotree_HelpLine = 0
let g:undotree_SetFocusWhenToggle = 1
let g:undotree_WindowLayout = 2

nmap <silent> <F5> :UndotreeToggle<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-buftabline
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
let g:buftabline_plug_max = 15

nmap <Leader>1 <Plug>BufTabLine.Go(1)
nmap <Leader>2 <Plug>BufTabLine.Go(2)
nmap <Leader>3 <Plug>BufTabLine.Go(3)
nmap <Leader>4 <Plug>BufTabLine.Go(4)
nmap <Leader>5 <Plug>BufTabLine.Go(5)
nmap <Leader>6 <Plug>BufTabLine.Go(6)
nmap <Leader>7 <Plug>BufTabLine.Go(7)
nmap <Leader>8 <Plug>BufTabLine.Go(8)
nmap <Leader>9 <Plug>BufTabLine.Go(9)
nmap <Leader>10 <Plug>BufTabLine.Go(10)
nmap <Leader>11 <Plug>BufTabLine.Go(11)
nmap <Leader>12 <Plug>BufTabLine.Go(12)
nmap <Leader>13 <Plug>BufTabLine.Go(13)
nmap <Leader>14 <Plug>BufTabLine.Go(14)
nmap <Leader>15 <Plug>BufTabLine.Go(15)
nmap <Leader>0 <Plug>BufTabLine.Go(-1)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-dirvish
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:dirvish_mode = 2

highlight link DirvishSuffix LineNr

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-easy-align
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-easymotion
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_upper = 1

nmap <Leader>s <Plug>(easymotion-sn)
omap <Leader>s <Plug>(easymotion-sn)
xmap <Leader>s <Plug>(easymotion-sn)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-sandwhich
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:sandwich#magicchar#f#patterns = [
  \   {
  \     'header' : '\<\%(\h\k*\%(\.\|::\)\)*\h\k*\%(<\s\?\S*\s\?>\)\?',
  \     'bra'    : '(\s*',
  \     'ket'    : '\s*)',
  \     'footer' : ''
  \   }
  \ ]
let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
let g:sandwich#recipes += [
  \   {'buns': ['{ ', ' }'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['{']},
  \
  \   {'buns': ['{', '}'], 'kind': ['add', 'replace'], 'action': ['add'],
  \    'motionwise': ['line'], 'command': ["'[+1,']-1normal! =="]},
  \
  \   {'buns': ['^\s*{$', '^\s*}$'], 'nesting': 1, 'regex': 1, 'linewise': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['{{'], 'command': ["'[,']normal! =="]},
  \
  \   {'buns': ['[ ', ' ]'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['[']},
  \
  \   {'buns': ['( ', ' )'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['(']},
  \
  \   {'buns': ['< ', ' >'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['<']},
  \
  \   {'buns': ['{\s*', '\s*}'], 'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['{']},
  \
  \   {'buns': ['\[\s*', '\s*\]'], 'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['[']},
  \
  \   {'buns': ['(\s*', '\s*)'],   'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['(']},
  \
  \   {'buns': ['<\s*', '\s*>'],   'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['<']}
  \ ]
let g:textobj_sandwich_function_searchlines = 2

nmap s <Nop>
xmap s <Nop>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-startify
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:startify_change_to_dir = 0
let g:startify_lists = [
      \ { 'type': 'sessions',  'header': ['   Sessions']       },
      \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
      \ { 'type': 'files',     'header': ['   MRU']            },
      \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
      \ { 'type': 'commands',  'header': ['   Commands']       }
      \ ]

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-textobj-user
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

call textobj#user#plugin('comment', {
      \   'multiline': {
      \     'pattern': ['^\s*/\*\*', '^\s*\*\+/'],
      \     'region-type': 'V',
      \     'select-a': 'am',
      \     'select-i': 'im'
      \   }
      \ })

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General key maps
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:better_g_under()
  let col = col('.') - 1
  if getline('.')[0:col] =~# '^\s*$'
    return "^"
  else
    return "g_"
  endif
endfunction

function! s:better_zero()
  let col = col('.') - 2
  if col < 0 || getline('.')[0:col] =~# '^\s*$'
    return "0"
  else
    return "^"
  endif
endfunction

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1] =~# '\s'
endfunction

function! s:cmake_format()
  let save_pos = getpos('.')[1:2]
  execute '%!cmake-format %'
  call cursor(save_pos)
endfunction

function! s:last_buf() abort
  if buflisted(0)
    b #
  else
    bp
  endif
endfunction

function! s:safe_close() abort
  call s:last_buf()
  bd #
endfunction

function! s:scratch (command, ...)
  let save_more = &more
  set nomore
  redir => lines
  execute a:command
  redir END
  let &more = save_more
  call feedkeys("\<CR>")
  new +only
  setlocal buftype=nofile bufhidden=hide noswapfile
  put =lines
  if a:0
    execute 'v/' . a:1 . '/d'
  endif
  0
endfunction
command! -nargs=+ Scratch call <SID>scratch(<f-args>)

function! s:compareQuickfixEntries(i1, i2)
  if bufname(a:i1.bufnr) == bufname(a:i2.bufnr)
    return a:i1.lnum == a:i2.lnum ? 0 : (a:i1.lnum < a:i2.lnum ? -1 : 1)
  else
    return bufname(a:i1.bufnr) < bufname(a:i2.bufnr) ? -1 : 1
  endif
endfunction

function! s:sortUniqQFList(...)
  if a:0
    let sortedList = sort(getloclist(), 's:compareQuickfixEntries')
  else
    let sortedList = sort(getqflist(), 's:compareQuickfixEntries')
  endif
  let uniqedList = []
  let last = ''
  for item in sortedList
    let this = bufname(item.bufnr) . "\t" . item.lnum
    if this !=# last
      call add(uniqedList, item)
      let last = this
    endif
  endfor
  if a:0
    call setloclist(uniqedList)
  else
    call setqflist(uniqedList)
  endif
endfunction

function! s:ulti_expandable()
  return !(
        \ col('.') <= 1
        \ || !empty(matchstr(getline('.'), '\%' . (col('.') - 1) . 'c\s'))
        \ || empty(UltiSnips#SnippetsInCurrentScope())
        \ )
endfunction

command! NvConfig edit $HOME/.dotfiles/vim/vimrc

cnoremap <C-a> <Home>
cnoremap <C-b> <Left>
cnoremap <C-d> <S-Right>
cnoremap <C-e> <End>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-s> <S-Left>
inoremap <silent> <expr> <Tab>
      \ <SID>ulti_expandable() ? "\<C-r>=UltiSnips#ExpandSnippet()\<CR>" :
      \ pumvisible() ? coc#_select_confirm() :
      \ <SID>check_back_space() ? "\<Tab>" :
      \ coc#refresh()
inoremap jj <Esc>
noremap \ ,
nnoremap <silent> <Leader><Space> :nohlsearch<CR>:diffupdate<CR>:syntax sync fromstart<CR>:mode<CR>
nnoremap <silent> <Leader><Tab> :call <SID>last_buf()<CR>
nnoremap <silent> <Leader>- :split<CR>
nnoremap <silent> <Leader>/ :vsplit<CR>
nnoremap <silent> <Leader>c :call <SID>safe_close()<CR>
nnoremap <silent> <Leader>q :q<CR>
nnoremap <silent> <Leader>qa :qa<CR>
nnoremap <silent> <Leader>qlc :lclose<CR>zz
nnoremap <silent> <Leader>qlr :lclose<CR>zz:call setloclist(0, [])<CR>
nnoremap <silent> <Leader>qlo :lopen<CR><C-w>pzz
nnoremap <silent> <Leader>qls :call <SID>sortUniqQFList(1)<CR>
nnoremap <silent> <Leader>qc :cclose<CR>zz
nnoremap <silent> <Leader>qr :cclose<CR>zz:call setqflist([])<CR>
nnoremap <silent> <Leader>qs :call <SID>sortUniqQFList()<CR>
nnoremap <silent> <Leader>qo :copen<CR><C-w>pzz
nnoremap <silent> <Leader>Q :call <SID>safe_close()<CR>:q<CR>
nnoremap <silent> <Leader>w :w<CR>
nnoremap <Space>gd gd
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
noremap ; :
noremap p ]p
noremap P ]P
nnoremap <silent> <expr> 0 <SID>better_zero()
onoremap <silent> <expr> 0
      \ col('.') == len(getline('.')) ?
      \ "v" . <SID>better_zero() :
      \ <SID>better_zero()
xnoremap <silent> <expr> 0 <SID>better_zero()
nnoremap <silent> <expr> g_ <SID>better_g_under()
onoremap <silent> <expr> g_ <SID>better_g_under()
xnoremap <silent> <expr> g_ <SID>better_g_under()
map H 0
map L g_
vmap < <gv
vmap > >gv

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General autocmds
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:autoSaveWinView()
  if !exists("w:SavedBufView")
    let w:SavedBufView = {}
  endif
  let w:SavedBufView[bufnr("%")] = winsaveview()
endfunction

function! s:autoRestoreWinView()
  let buf = bufnr("%")
  if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
    let v = winsaveview()
    let atStartOfFile = v.lnum == 1 && v.col == 0
    if atStartOfFile && !&diff
      call winrestview(w:SavedBufView[buf])
    endif
    unlet w:SavedBufView[buf]
  endif
endfunction

let g:easymotion#is_active = 0
function! s:easyMotionCoc() abort
  if EasyMotion#is_active()
    let g:easymotion#is_active = 1
    silent! CocDisable
  else
    if g:easymotion#is_active == 1
      let g:easymotion#is_active = 0
      silent! CocEnable
    endif
  endif
endfunction

let g:doxygen_end_punctuation='\n\%(\s*\*\s*@param\|\s*\*\{2,}/\)\@='

augroup myautocmd
  autocmd!
  autocmd BufEnter * call s:autoRestoreWinView()
  autocmd BufLeave * call s:autoSaveWinView()
  autocmd BufNewFile,BufRead .clang-format set filetype=yaml
  autocmd BufNewFile,BufReadPre *.c,*.cpp,*.h,*.hpp,*.java let b:load_doxygen_syntax=1
  autocmd BufWritePost ~/.dotfiles/vim/vimrc ++nested source ~/.dotfiles/vim/vimrc
  autocmd FileType c,cpp,h,hpp,java,snippets setlocal expandtab tabstop=4 shiftwidth=4
  autocmd FileType cmake nnoremap <buffer> <silent> <Space>f :w<CR>:call <SID>cmake_format()<CR>
  autocmd FileType help nnoremap <buffer> <silent> q :q<CR>
  autocmd FileType help,man nnoremap <buffer> d <C-d>
  autocmd FileType help,man nnoremap <buffer> u <C-u>
  autocmd FileType man nnoremap <buffer> <silent> q :call <SID>safe_close()<CR>:if winnr('$') > 1 <Bar> q <Bar> endif<CR>
  autocmd FileType man wincmd _
  autocmd FileType json syntax match Comment +\/\/.\+$+
  autocmd InsertEnter,WinLeave * set nocursorline
  autocmd InsertLeave,WinEnter * set cursorline
  autocmd TextChanged,CursorMoved * call s:easyMotionCoc()
augroup end
