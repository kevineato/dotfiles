""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if !has('nvim')
  call plug#begin('~/.vim/plugged')
else
  call plug#begin(stdpath('data') . '/plugged')
endif
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'lfilho/cosco.vim'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'morhetz/gruvbox'
Plug 'itchyny/lightline.vim'
Plug 'preservim/nerdcommenter'
Plug 'godlygeek/tabular'
Plug 'kevineato/tagbar'
Plug 'tomtom/tinykeymap_vim'
Plug 'SirVer/ultisnips'
Plug 'ap/vim-buftabline'
Plug 'ryanoasis/vim-devicons'
Plug 'justinmk/vim-dirvish'
Plug 'easymotion/vim-easymotion'
Plug 'farmergreg/vim-lastplace'
Plug 'jackguo380/vim-lsp-cxx-highlight'
Plug 'terryma/vim-multiple-cursors'
Plug 'reconquest/vim-pythonx'
Plug 'tpope/vim-repeat'
Plug 'mhinz/vim-startify'
" Plug 'kana/vim-submode'
Plug 'tpope/vim-surround'
" Plug 'liuchengxu/vista.vim'
call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

filetype plugin indent on

if !has('nvim')
  set autoindent
  set autoread
  set background=dark
  set backspace=indent,eol,start
  set belloff=all
  set complete-=i
  set cscopeverbose
  set display=lastline
  set encoding=utf-8
  set fileencoding=utf-8
  set fileencodings=utf-8
  set formatoptions+=j
  set history=10000
  set hlsearch
  set incsearch
  set langnoremap
  set laststatus=2
  set listchars="tab:> ,trail:-,nbsp+"
  set nocompatible
  set nofsync
  set nostartofline
  set nrformats=bin,hex
  set ruler
  set sessionoptions-=options
  set shortmess+=F
  set shortmess-=S
  set sidescroll=1
  set t_Co=256
  set t_ut=
  set tabpagemax=50
  set ttimeoutlen=50
  set ttyfast
  set viminfo+=!
  set wildmenu
  syntax enable
else
  set nosmarttab
endif

colorscheme gruvbox
set breakindent
set breakindentopt=sbr
set clipboard=unnamed,unnamedplus
set cmdheight=2
set completeopt=menuone,preview,noinsert,noselect
set expandtab
set grepprg=rg\ --vimgrep
set helpheight=9999
set hidden
set ignorecase
set mouse=a
set mousemodel=popup
set nobackup
set noshowcmd
set noshowmode
set nowritebackup
set number relativenumber
set shiftwidth=2
set shortmess+=c
set showbreak=ï¬Œ
set signcolumn=yes
set smartcase
set tabstop=2
set termguicolors
set timeoutlen=300
set updatetime=300
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__
set wildmode=longest:full,full
set wrap

let mapleader = ','

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" coc.nvim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:coc_node_path = '/usr/bin/node'
let g:coc_snippet_next = "<Tab>"
let g:coc_snippet_prev = "<S-Tab>"
let g:markdown_fenced_languages = [
      \ 'vim',
      \ 'help'
      \ ]

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

command! -nargs=? Fold :call CocAction('fold', <f-args>)
command! -nargs=0 Format :call CocAction('format')

nmap <Leader>df <Plug>(coc-format-selected)
nmap <Leader>rn <Plug>(coc-rename)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> gy <Plug>(coc-type-definition)
nnoremap <silent> <Space>c :<C-u>CocList commands<CR>
nnoremap <silent> <Space>e :<C-u>CocList extensions<CR>
nnoremap <silent> <Space>E :<C-u>CocList marketplace<CR>
nnoremap <silent> <Space>f :<C-u>Format<CR>
nnoremap <silent> <Space>j :<C-u>CocNext<CR>
nnoremap <silent> <Space>k :<C-u>CocPrev<CR>
nnoremap <silent> <Space>o :<C-u>CocList -A outline<CR>
nnoremap <silent> <Space>r :<C-u>CocListResume<CR>
nnoremap <silent> <Space>R :<C-u>CocRestart<CR>
nnoremap <silent> <Space>s :<C-u>CocList -I -A symbols<CR>
nnoremap <silent> K :call <SID>show_documentation()<CR>
omap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
xmap <Leader>df <Plug>(coc-format-selected)
xmap af <Plug>(coc-funcobj-a)
xmap if <Plug>(coc-funcobj-i)

augroup mycocnvim
  autocmd!
  autocmd CursorHold * silent call CocActionAsync('highlight')
  autocmd CursorHoldI * silent call CocActionAsync('showSignatureHelp')
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cosco.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup mycosco
  autocmd!
  autocmd FileType c,cpp,h,hpp,java imap <silent> <Leader>; <C-o><Plug>(cosco-commaOrSemiColon)
  autocmd FileType c,cpp,h,hpp,java nmap <silent> <Leader>; <Plug>(cosco-commaOrSemiColon)
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" fzf.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! RipgrepFzf(query, args, fullscreen)
  let command_fmt = 'rg --pcre2 --no-heading --color=always --smart-case %s %s || true'
  let initial_command = printf(command_fmt, a:args, shellescape(a:query))
  let reload_command = printf(command_fmt, a:args, '{q}')
  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

function! s:fzf_buflist()
  redir => ls
  silent ls!
  redir END
  let filtered = filter(split(ls, '\n'), "v:val !~ '/tmp/\\|Tagbar\\|/\"\\|\\[Scratch]'")
  let filtered = map(filtered, "substitute(v:val, '.*\"\\(.\\+\\)\".*', '\\1', '')")
  return filter(filtered, "filereadable(glob(v:val)) && !buflisted(glob(v:val))")
endfunction

command! Mru call fzf#run(fzf#vim#with_preview({
      \   'source': reverse(<SID>fzf_buflist()),
      \   'sink': 'e',
      \   'options': '+m',
      \   'down': '40%'
      \ }))
command! -bang -nargs=* RG call RipgrepFzf(<q-args>, '--column --line-number', <bang>0)
command! -bang -nargs=* RGFiles call RipgrepFzf(<q-args>, '--files-with-matches', <bang>0)

nmap <leader>y :History:<CR>
nnoremap <silent> <Leader>b :Buffers<CR>
nnoremap <silent> <Leader>B :Mru<CR>
nnoremap <silent> <Leader>e :FZF -m<CR>
nnoremap <silent> <Leader>f :RG<CR>
nnoremap <silent> <Leader>F :RGFiles<CR>
nnoremap <silent> <Leader>l :BLines<CR>
nnoremap <silent> <Leader>o :Files<CR> .cpp$ \| .h$ 

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:lightline = {
      \ 'active': {
      \ 'left': [['mode', 'paste'],
      \ ['readonly', 'filename', 'modified', 'cocstatus']] },
      \ 'colorscheme': 'gruvbox',
      \ 'component': { 'cocstatus': '%{get(b:, "coc_current_function", "")}' }
      \ }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" nerdcommenter
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:NERDCustomDelimiters = {
      \ 'json': { 'left': '//' }
      \ }
let g:NERDSpaceDelims = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tabular
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:align_comment()
  let tab_param = "call Tabularize('/.*@param \\zs\\w\\+\\|\\*\\zs /l1l2')"
  let tab_ret = "call Tabularize('/.*@return\\zs \\|\\*\\zs /l0')"
  let c_begin = search('\/\*\*', 'bcn')
  let c_end = search('\*\/', 'cn')
  let save_pos = getpos('.')
  call cursor(c_begin, save_pos[2])
  if search('@param', '', c_end)
    let p_begin = line('.')
    while search('@param', '', c_end)
    endwhile
    if search('@return', '', c_end)
      let p_end = line('.') - 1
    else
      let p_end = c_end - 1
    endif
    execute p_begin . ',' . p_end . tab_param
  endif
  if search('@return', 'c', c_end)
    let r_begin = line('.')
    execute r_begin . ',' . (c_end - 1) . tab_ret
  endif
  call cursor(save_pos[1], save_pos[2])
endfunction

augroup mytabular
  autocmd!
  autocmd FileType c,cpp,h,hpp,java nnoremap <buffer> <silent> <Leader>ac :call <SID>align_comment()<CR>
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tagbar
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:tagbar_autofocus = 1
let g:tagbar_compact = 1
let g:tagbar_ctags_bin = $HOME . '/.local/bin/ctags'
let g:tagbar_show_linenumbers = 2
let g:tagbar_sort = 1
let g:tagbar_type_cpp = {
      \ 'ctagsargs': [
      \ '-f',
      \ '-',
      \ '--format=2',
      \ '--excmd=pattern',
      \ '--extras=+Fpr',
      \ '--fields=nksSaf',
      \ '--fields-C++=+{properties}{name}{captures}{template}{specialization}',
      \ '--language-force=C++',
      \ '--sort=no',
      \ '--append=no',
      \ '--kinds-C++=hdpgetncsufmv'
      \ ]
      \ }

nmap <silent> <F4> :TagbarToggle<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tinykeymap_vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:tinykeymap_multi_enter(prefix, mappings)
  let a:mappings['options']['name'] = a:prefix
  let ind = 0
  for [key, val] in items(a:mappings['startmaps'])
    let temp = deepcopy(a:mappings['options'])
    if has_key(val, 'start')
      let temp['start'] = val['start']
    endif
    if has_key(val, 'stop')
      let temp['stop'] = val['stop']
    else
      let temp['stop'] = 'mode'
    endif
    if has_key(val, 'after')
      let temp['after'] = val['after']
    endif
    call tinykeymap#EnterMap(a:prefix . ind, key, temp)
    for [m_key, m_val] in items(a:mappings['maps'])
      if type(m_val) == v:t_string
        call tinykeymap#Map(a:prefix . ind, m_key, m_val)
      elseif type(m_val) == v:t_dict
        call tinykeymap#Map(a:prefix . ind, m_key, m_val['cmd'], m_val['options'])
      endif
    endfor
    let ind += 1
  endfor
endfunction

let g:tinykeymaps_default = []
let g:tinykeymap#break_key = 113
let g:tinykeymap#conflict = 3
let g:tinykeymap#timeout = 0

" buffers
call s:tinykeymap_multi_enter('buffers', {
      \ 'startmaps': {
      \ '[b': {'start': 'bprevious'},
      \ ']b': {'start': 'bnext'}
      \ },
      \ 'maps': {
      \ '[': '<count1>bprevious',
      \ ']': '<count1>bnext'
      \ },
      \ 'options': {
      \ 'timeout': 1000
      \ }
      \ })

" curly
function! SearchCurly(square, curly)
  if a:square == ']'
    silent! call search('^\s*' . a:curly . ';\?$', 'esW')
  elseif a:square == '['
    silent! call search('^\s*' . a:curly . ';\?$', 'besW')
  endif
endfunction

call s:tinykeymap_multi_enter('curly', {
      \ 'startmaps': {
      \ '[{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("[", "{") | normal! zz'},
      \ ']{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("]", "{") | normal! zz'},
      \ '[}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("[", "}") | normal! zz'},
      \ ']}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("]", "}") | normal! zz'},
      \ },
      \ 'maps': {
      \ '[': 'call SearchCurly("[", g:vimrc#last_curly)',
      \ ']': 'call SearchCurly("]", g:vimrc#last_curly)'
      \ },
      \ 'options': {
      \ 'after': 'normal! zz'
      \ }
      \ })

" movement
call tinykeymap#EnterMap('movement', '<Space>.', {'stop': 'mode', 'after': 'normal! zz'})
call tinykeymap#Map('movement', 'd', "normal! \<C-d>")
call tinykeymap#Map('movement', 'j', 'normal! j')
call tinykeymap#Map('movement', 'k', 'normal! k')
call tinykeymap#Map('movement', 'u', "normal! \<C-u>")

" quickfix
call s:tinykeymap_multi_enter('quickfix', {
      \ 'startmaps': {
      \ '[q': {'start': 'cprevious | normal! zz'},
      \ ']q': {'start': 'cnext | normal! zz'}
      \ },
      \ 'maps': {
      \ '[': '<count1>cprevious',
      \ ']': '<count1>cnext',
      \ 'c': {'cmd': 'cclose', 'options': {'exit': 1}}
      \ },
      \ 'options': {
      \ 'after': 'normal! zz'
      \ }
      \ })

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ultisnips
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsJumpForwardTrigger = "<C-j>"
let g:UltiSnipsSnippetDirectories=[$HOME . '/.vim/CustomSnips']

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-buftabline
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
let g:buftabline_plug_max = 15

nmap <Leader>1 <Plug>BufTabLine.Go(1)
nmap <Leader>2 <Plug>BufTabLine.Go(2)
nmap <Leader>3 <Plug>BufTabLine.Go(3)
nmap <Leader>4 <Plug>BufTabLine.Go(4)
nmap <Leader>5 <Plug>BufTabLine.Go(5)
nmap <Leader>6 <Plug>BufTabLine.Go(6)
nmap <Leader>7 <Plug>BufTabLine.Go(7)
nmap <Leader>8 <Plug>BufTabLine.Go(8)
nmap <Leader>9 <Plug>BufTabLine.Go(9)
nmap <Leader>10 <Plug>BufTabLine.Go(10)
nmap <Leader>11 <Plug>BufTabLine.Go(11)
nmap <Leader>12 <Plug>BufTabLine.Go(12)
nmap <Leader>13 <Plug>BufTabLine.Go(13)
nmap <Leader>14 <Plug>BufTabLine.Go(14)
nmap <Leader>15 <Plug>BufTabLine.Go(15)
nmap <Leader>0 <Plug>BufTabLine.Go(-1)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-dirvish
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:dirvish_mode = 2

highlight link DirvishSuffix LineNr

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-easymotion
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_upper = 1

nmap <Plug>(easymotion-prefix)s <Plug>(easymotion-sn)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-startify
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:startify_change_to_dir = 0

nnoremap <Leader>S :Startify<CR>
nnoremap <Leader>SC :SClose<CR>
nnoremap <Leader>SD :SDelete<CR>
nnoremap <Leader>SL :SLoad<CR>
nnoremap <Leader>SS :SSave<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-submode
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" function! s:map_submode_leader(name, lead_prefix, map_prefix, maps)
" call submode#enter_with(a:name, 'n', '', '<Leader>' . a:lead_prefix, '<Esc>')
" let split_temp = split(a:maps, '\zs')
" let split_maps = []
" let ind = 0
" while ind < len(split_temp)
" let temp = split_temp[ind]
" if temp =~ '<'
" let ind += 1
" while split_temp[ind] !~ '>'
" let temp .= split_temp[ind]
" let ind += 1
" endwhile
" let temp .= split_temp[ind]
" endif
" call add(split_maps, temp)
" let ind += 1
" endwhile
" for mapping in split_maps
" call submode#enter_with(a:name, 'n', '', '<Leader>' . a:lead_prefix . mapping, a:map_prefix . mapping)
" call submode#map(a:name, 'n', '', mapping, a:map_prefix . mapping)
" endfor
" endfunction

" let g:submode_always_show_submode = 1
" let g:submode_keep_leaving_key = 1
" let g:submode_keyseqs_to_leave = ['<Esc>', 'q']
" let g:submode_timeout = 0
" let g:submode_timeoutlen = 1000

" " movement
" call submode#enter_with('movement', 'n', '', '<Space>.')
" call submode#map('movement', 'n', '', 'd', '<C-d>')
" call submode#map('movement', 'n', '', 'j', '<C-e>')
" call submode#map('movement', 'n', '', 'k', '<C-y>')
" call submode#map('movement', 'n', '', 'u', '<C-u>')

" " tabline
" call submode#enter_with('tabline', 'n', '', ']b', ':bn<CR>', 1)
" call submode#enter_with('tabline', 'n', '', '[b', ':bp<CR>', 1)
" call submode#map('tabline', 'n', '', ']', ':bn<CR>')
" call submode#map('tabline', 'n', '', '[', ':bp<CR>')

" " window
" call s:map_submode_leader('window', 'w', '<C-w>', '<Bar>=_chjklwW')
" call submode#map('window', 'n', '', '-', '<C-w>s')
" call submode#map('window', 'n', '', '/', '<C-w>v')

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General key maps
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1] =~# '\s'
endfunction

function! s:cmake_format()
  let save_pos = getpos('.')
  execute '%!cmake-format %'
  call cursor(save_pos[1], save_pos[2])
endfunction

function! s:last_buf() abort
  if buflisted(0)
    b #
  else
    bp
  endif
endfunction

function! s:safe_close() abort
  call s:last_buf()
  bd #
endfunction

function! s:scratch (command, ...)
  let save_more = &more
  set nomore
  redir => lines
  execute a:command
  redir END
  let &more = save_more
  call feedkeys("\<CR>")
  new
  setlocal buftype=nofile bufhidden=hide noswapfile
  put =lines
  if a:0 > 0
    execute 'v/' . a:1 . '/d'
  endif
  0
endfunction
command! -nargs=+ Scratch call <SID>scratch(<f-args>)

function! s:CompareQuickfixEntries(i1, i2)
  if bufname(a:i1.bufnr) == bufname(a:i2.bufnr)
    return a:i1.lnum == a:i2.lnum ? 0 : (a:i1.lnum < a:i2.lnum ? -1 : 1)
  else
    return bufname(a:i1.bufnr) < bufname(a:i2.bufnr) ? -1 : 1
  endif
endfunction

function! s:SortUniqQFList(is_loc)
  if a:is_loc
    let sortedList = sort(getloclist(), 's:CompareQuickfixEntries')
  else
    let sortedList = sort(getqflist(), 's:CompareQuickfixEntries')
  endif
  let uniqedList = []
  let last = ''
  for item in sortedList
    let this = bufname(item.bufnr) . "\t" . item.lnum
    if this !=# last
      call add(uniqedList, item)
      let last = this
    endif
  endfor
  if a:is_loc
    call setloclist(uniqedList)
    lfirst
  else
    call setqflist(uniqedList)
    cfirst
  endif
  normal! zz
endfunction

function! s:ulti_expandable()
  return !(
        \ col('.') <= 1
        \ || !empty(matchstr(getline('.'), '\%' . (col('.') - 1) . 'c\s'))
        \ || empty(UltiSnips#SnippetsInCurrentScope())
        \ )
endfunction

command! NvConfig edit $HOME/.dotfiles/vim/vimrc

cnoremap <C-a> <Home>
cnoremap <C-b> <Left>
cnoremap <C-d> <S-Right>
cnoremap <C-e> <End>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-s> <S-Left>
inoremap <silent> <expr> <Tab>
      \ <SID>ulti_expandable() ? "\<C-r>=UltiSnips#ExpandSnippet()\<CR>" :
      \ <SID>check_back_space() ? "\<Tab>" :
      \ coc#refresh()
inoremap jj <Esc>
" nnoremap <silent> [l :<C-u>execute v:count1 . "lprevious"<CR>zz
" nnoremap <silent> ]l :<C-u>execute v:count1 . "lnext"<CR>zz
" nnoremap <silent> [w <C-w>w
" nnoremap <silent> ]w <C-w>W
nnoremap <silent> <Leader><Space> :nohlsearch<CR>:diffupdate<CR>:syntax sync fromstart<CR>:mode<CR>
nnoremap <silent> <Leader><Tab> :call <SID>last_buf()<CR>
nnoremap <silent> <Leader>- :split<CR>
nnoremap <silent> <Leader>/ :vsplit<CR>
nnoremap <silent> <Leader>c :call <SID>safe_close()<CR>
nnoremap <silent> <Leader>q :q<CR>
nnoremap <silent> <Leader>qlc :lclose<CR>zz
nnoremap <silent> <Leader>qlo :lopen<CR><C-w>pzz
nnoremap <silent> <Leader>qls :call <SID>SortUniqQFList(1)<CR>
nnoremap <silent> <Leader>qc :cclose<CR>zz
nnoremap <silent> <Leader>qs :call <SID>SortUniqQFList(0)<CR>
nnoremap <silent> <Leader>qo :copen<CR><C-w>pzz
nnoremap <silent> <Leader>Q :call <SID>safe_close()<CR>:q<CR>
nnoremap <silent> <Leader>s :w<CR>
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
vmap < <gv
vmap > >gv

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General autocmds
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup myautocmd
  autocmd!
  autocmd BufWritePost ~/.dotfiles/vim/vimrc ++nested source ~/.dotfiles/vim/vimrc
  autocmd FileType c,cpp,h,hpp,java,snippets setlocal expandtab tabstop=4 shiftwidth=4
  autocmd FileType cmake nnoremap <buffer> <silent> <Space>f :w<CR>:call <SID>cmake_format()<CR>
  autocmd FileType help nnoremap <buffer> <silent> q :q<CR>
  autocmd FileType json syntax match Comment +\/\/.\+$+
  autocmd FileType man nnoremap <buffer> <silent> q :call <SID>safe_close()<CR>:q<CR>
  autocmd InsertEnter,WinLeave * set nocursorline
  autocmd InsertLeave,WinEnter * set cursorline
augroup end
