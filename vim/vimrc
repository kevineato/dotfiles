""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if !has('nvim')
  call plug#begin('~/.vim/plugged')
else
  call plug#begin(stdpath('data') . '/plugged')
endif
Plug 'jiangmiao/auto-pairs'
Plug 'tjdevries/coc-zsh'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'lfilho/cosco.vim'
" Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
" Plug 'junegunn/fzf.vim'
Plug 'morhetz/gruvbox'
Plug 'haya14busa/is.vim'
Plug 'itchyny/lightline.vim'
Plug 'preservim/nerdcommenter'
Plug 'lotabout/skim', { 'dir': '~/.skim', 'do': './install'  }
Plug 'lotabout/skim.vim'
Plug 'godlygeek/tabular'
Plug 'kevineato/tagbar'
Plug 'tomtom/tinykeymap_vim'
Plug 'SirVer/ultisnips'
Plug 'ap/vim-buftabline'
Plug 'ryanoasis/vim-devicons'
Plug 'justinmk/vim-dirvish'
Plug 'easymotion/vim-easymotion'
Plug 'tpope/vim-fugitive'
Plug 'farmergreg/vim-lastplace'
Plug 'jackguo380/vim-lsp-cxx-highlight'
Plug 'terryma/vim-multiple-cursors'
Plug 'reconquest/vim-pythonx'
Plug 'tpope/vim-repeat'
Plug 'kevineato/vim-sandwich'
Plug 'mhinz/vim-startify'
" Plug 'tpope/vim-surround'
" Plug 'liuchengxu/vista.vim'
call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General settings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

filetype plugin indent on

if !has('nvim')
  set autoindent
  set autoread
  set background=dark
  set backspace=indent,eol,start
  set belloff=all
  set complete-=i
  set cscopeverbose
  set display=lastline
  set encoding=utf-8
  set fileencoding=utf-8
  set fileencodings=utf-8
  set formatoptions+=j
  set history=10000
  set hlsearch
  set incsearch
  set langnoremap
  set laststatus=2
  set listchars="tab:> ,trail:-,nbsp+"
  set nocompatible
  set nofsync
  set nostartofline
  set nrformats=bin,hex
  set ruler
  set sessionoptions-=options
  set shortmess+=F
  set shortmess-=S
  set sidescroll=1
  set t_Co=256
  set t_ut=
  set tabpagemax=50
  set ttimeoutlen=50
  set ttyfast
  set viminfo+=!
  set wildmenu
  syntax enable
else
  set nosmarttab
endif

colorscheme gruvbox
set breakindent
set breakindentopt=sbr
set clipboard=unnamed,unnamedplus
set cmdheight=2
set completeopt=menuone,preview,noinsert,noselect
set expandtab
set grepprg=rg\ --vimgrep
set helpheight=9999
set hidden
set ignorecase
set mouse=a
set mousemodel=popup
set nobackup
set noshowcmd
set noshowmode
set nowritebackup
set number relativenumber
set shiftwidth=2
set shortmess+=c
set showbreak=ï¬Œ
set signcolumn=yes
set smartcase
set tabstop=2
set termguicolors
set timeoutlen=300
set updatetime=300
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__
set wildmode=longest:full,full
set wrap

let mapleader = ','

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" auto-pairs
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup myautopairs
  autocmd!
  autocmd FileType c,cpp,h,hpp,java,snippets let b:AutoPairs = AutoPairsDefine({'\w\zs<': '>'})
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" coc.nvim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:coc_global_extensions = [
      \   "coc-clangd",
      \   "coc-cmake",
      \   "coc-css",
      \   "coc-explorer",
      \   "coc-html",
      \   "coc-java",
      \   "coc-json",
      \   "coc-lists",
      \   "coc-marketplace",
      \   "coc-python",
      \   "coc-sh",
      \   "coc-snippets",
      \   "coc-tsserver",
      \   "coc-ultisnips",
      \   "coc-vimlsp",
      \   "coc-xml",
      \   "coc-yaml"
      \ ]
let g:coc_snippet_next = "<C-j>"
let g:coc_snippet_prev = "<C-k>"
let g:markdown_fenced_languages = [
      \ 'vim',
      \ 'help'
      \ ]

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

command! -nargs=? Fold :call CocAction('fold', <f-args>)
command! -nargs=0 Format :call CocAction('format')

nmap <Leader>df <Plug>(coc-format-selected)
nmap <Leader>rn <Plug>(coc-rename)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> gy <Plug>(coc-type-definition)
nnoremap <expr> <C-f> coc#util#has_float() ? coc#util#float_scroll(1) : "\<C-f>"
nnoremap <expr> <C-b> coc#util#has_float() ? coc#util#float_scroll(0) : "\<C-b>"
nnoremap <silent> <Space>c :<C-u>CocList commands<CR>
nnoremap <silent> <Space>e :<C-u>CocCommand explorer<CR>
nnoremap <silent> <Space>ef :<C-u>CocCommand explorer --reveal <C-r>=expand('%')<CR><CR>
nnoremap <silent> <Space>E :<C-u>CocList marketplace<CR>
nnoremap <silent> <Space>f :<C-u>Format<CR>
nnoremap <silent> <Space>j :<C-u>CocNext<CR>
nnoremap <silent> <Space>k :<C-u>CocPrev<CR>
nnoremap <silent> <Space>o :<C-u>CocList -A outline<CR>
" nnoremap <silent> <Space>q :<C-u>CocList -A --normal quickfix<CR>
nnoremap <silent> <Space>r :<C-u>CocListResume<CR>
nnoremap <silent> <Space>R :<C-u>CocRestart<CR>
nnoremap <silent> <Space>s :<C-u>CocList -I -A symbols<CR>
nnoremap <silent> K :call <SID>show_documentation()<CR>
omap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
xmap <Leader>df <Plug>(coc-format-selected)
xmap af <Plug>(coc-funcobj-a)
xmap if <Plug>(coc-funcobj-i)

augroup mycocnvim
  autocmd!
  autocmd CursorHold * silent call CocActionAsync('highlight')
  autocmd CursorHoldI * silent call CocActionAsync('showSignatureHelp')
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cosco.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup mycosco
  autocmd!
  autocmd FileType c,cpp,h,hpp,java imap <silent> <Leader>; <C-o><Plug>(cosco-commaOrSemiColon)
  autocmd FileType c,cpp,h,hpp,java nmap <silent> <Leader>; <Plug>(cosco-commaOrSemiColon)
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" skim.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:skim_layout = { 'down': '~40%'  }

function! s:my_skim_rg_handler(lines, has_column)
  if len(a:lines) < 2
    return
  endif

  function! s:my_rg_to_qf(line, has_column)
    let parts = split(a:line, '[^:]\zs:\ze[^:]')
    let text = join(parts[(a:has_column ? 3 : 2):], ':')
    let dict = {'filename': &acd ? fnamemodify(parts[0], ':p') : parts[0], 'lnum': parts[1], 'text': text}
    if a:has_column
      let dict.col = parts[2]
    endif
    return dict
  endfunction

  let list = map(filter(a:lines[1:], 'len(v:val)'), 's:my_rg_to_qf(v:val, a:has_column)')

  if len(list) == 1
    execute 'e' list[0].filename
    call cursor([list[0].lnum, list[0].col])
    call feedkeys('zz')
    return
  endif

  call setqflist(list)
  call s:sortUniqQFList()
  execute 'CocList -A --normal quickfix'
endfunction

function! RipgrepSkim(query, args, do_curr_dir)
  let command_fmt = 'rg --pcre2 --no-heading --color=always --smart-case %s "{}" %s'
  let curr_dir = a:do_curr_dir ? expand('%:h') : '.'
  let rg_command = printf(command_fmt, a:args, curr_dir)

  let has_column = a:args =~# '--column'
  let opts = {
  \   'column': has_column,
  \   'options': [
  \     '-i', '-c', rg_command,
  \     '--ansi', '--cmd-prompt', 'rg> ',
  \     '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
  \      '--color', 'hl:4,hl+:12'
  \   ],
  \   'source': 'none'
  \ }

  if !has_column
    let opts['sink'] = 'e'
    let wrapped = s:skim_wrap('rg', opts, 'sink')
  else
    function! opts.sink(lines)
      return s:my_skim_rg_handler(a:lines, self.column)
    endfunction
    let opts['sink*'] = remove(opts, 'sink')
    let wrapped = s:skim_wrap('rg', opts, 'sink*')
  endif
  call skim#run(wrapped)
endfunction

function! s:skim_wrap(name, opts, ...)
  if a:0
    let sinks = {}
    for key in split(a:1)
      let sinks[key] = remove(a:opts, key)
    endfor
  endif
  let wrapped = skim#wrap(a:name, fzf#vim#with_preview(a:opts, 'right:50%', 'alt-h'))
  if a:0
    for key in keys(sinks)
      let wrapped[key] = sinks[key]
    endfor
  endif
  return wrapped
endfunction

function! s:skim_buflist(do_mru)
  if a:do_mru
    redir => ls
    silent ls!
    redir END
    let filtered = filter(split(ls, '\n'), "v:val !~ '/tmp/\\|Tagbar\\|/\"\\|\\[Scratch]'")
    let filtered = map(filtered, "expand(substitute(v:val, '.*\"\\(.\\+\\)\".*', '\\1', ''))")
    return filter(filtered, "filereadable(glob(v:val)) && !buflisted(glob(v:val))")
  endif
  redir => ls
  silent ls
  redir END
  let filtered = map(split(ls, '\n'), "expand(substitute(v:val, '.*\"\\(.\\+\\)\".*', '\\1', ''))")
  return filter(filtered, "filereadable(glob(v:val))")
endfunction

command! Mru call skim#run(<SID>skim_wrap('mru' ,{
      \   'source': reverse(<SID>skim_buflist(1)),
      \   'options': ['--multi'],
      \   'down': '40%'
      \ }))
command! DBuffers call skim#run(<SID>skim_wrap('dBuffers', {
      \   'source': reverse(<SID>skim_buflist(0)),
      \   'sink': 'bd',
      \   'options': ['--multi'],
      \   'down': '40%'
      \ }))
command! -bang -nargs=* RG call RipgrepSkim(<q-args>, '--column --line-number', <bang>0)
command! -bang -nargs=* RGFiles call RipgrepSkim(<q-args>, '--files-with-matches', <bang>0)

nmap <leader>y :History:<CR>
nnoremap <silent> <Leader>b :Buffers<CR>
nnoremap <silent> <Leader>B :Mru<CR>
nnoremap <silent> <Leader>db :DBuffers<CR>
nnoremap <silent> <Leader>e :SK<CR>
nnoremap <silent> <Leader>ed :SK <C-r>=expand('%:h')<CR><CR>
nnoremap <silent> <Leader>f :RG<CR>
nnoremap <silent> <Leader>fd :RG!<CR>
nnoremap <silent> <Leader>F :RGFiles<CR>
nnoremap <silent> <Leader>Fd :RGFiles!<CR>
nnoremap <silent> <Leader>l :BLines<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:is#do_default_mappings = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" lightline.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:lightline = {
      \   'active': {
      \     'left': [['mode', 'paste'],
      \       ['readonly', 'filename', 'modified', 'cocstatus']]
      \   },
      \   'colorscheme': 'gruvbox',
      \   'component': { 'cocstatus': '%{get(b:, "coc_current_function", "")}' }
      \ }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" nerdcommenter
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:NERDCustomDelimiters = {
      \   'json': { 'left': '//' }
      \ }
let g:NERDSpaceDelims = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tabular
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:align_comment()
  let tab_param = "call Tabularize('/.*@param \\zs\\w\\+\\|\\*\\zs /l1l2')"
  let tab_ret = "call Tabularize('/.*@return\\zs \\|\\*\\zs /l0')"
  let c_begin = search('\/\*\*', 'bcn')
  let c_end = search('\*\/', 'cn')
  let save_pos = getpos('.')
  call cursor(c_begin, save_pos[2])
  if search('@param', '', c_end)
    let p_begin = line('.')
    while search('@param', '', c_end)
    endwhile
    if search('@return', '', c_end)
      let p_end = line('.') - 1
    else
      let p_end = c_end - 1
    endif
    execute p_begin . ',' . p_end . tab_param
  endif
  if search('@return', 'c', c_end)
    let r_begin = line('.')
    execute r_begin . ',' . (c_end - 1) . tab_ret
  endif
  call cursor(save_pos[1], save_pos[2])
endfunction

augroup mytabular
  autocmd!
  autocmd FileType c,cpp,h,hpp,java nnoremap <buffer> <silent> <Leader>ac :call <SID>align_comment()<CR>
augroup end

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tagbar
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:tagbar_autofocus = 1
let g:tagbar_compact = 1
let g:tagbar_ctags_bin = $HOME . '/.local/bin/ctags'
let g:tagbar_show_linenumbers = 2
let g:tagbar_sort = 1
let g:tagbar_type_cpp = {
      \   'ctagsargs': [
      \     '-f',
      \     '-',
      \     '--format=2',
      \     '--excmd=pattern',
      \     '--extras=+Fpr',
      \     '--fields=nksSaf',
      \     '--fields-C++=+{properties}{name}{captures}{template}{specialization}',
      \     '--language-force=C++',
      \     '--sort=no',
      \     '--append=no',
      \     '--kinds-C++=hdpgetncsufmv'
      \   ]
      \ }

nmap <silent> <F4> :TagbarToggle<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tinykeymap_vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:tinykeymaps_default = []
let g:tinykeymap#break_key = 113
let g:tinykeymap#conflict = 3
let g:tinykeymap#timeout = 0

if !empty(glob((has('nvim') ? stdpath('data') : '~/.vim') . '/plugged/tinykeymap_vim/plugin/tinykeymap.vim'))
  function! s:tinykeymap_multi_enter(prefix, mappings)
    let a:mappings['options']['name'] = a:prefix
    let ind = 0
    for [key, val] in items(a:mappings['startmaps'])
      let temp = deepcopy(a:mappings['options'])
      if has_key(val, 'start')
        let temp['start'] = val['start']
      endif
      if has_key(val, 'stop')
        let temp['stop'] = val['stop']
      else
        let temp['stop'] = 'mode'
      endif
      if has_key(val, 'after')
        let temp['after'] = val['after']
      endif
      call tinykeymap#EnterMap(a:prefix . ind, key, temp)
      for [m_key, m_val] in items(a:mappings['maps'])
        if type(m_val) == v:t_string
          call tinykeymap#Map(a:prefix . ind, m_key, m_val)
        elseif type(m_val) == v:t_dict
          call tinykeymap#Map(a:prefix . ind, m_key, m_val['cmd'], m_val['options'])
        endif
      endfor
      let ind += 1
    endfor
  endfunction

  " buffers
  call s:tinykeymap_multi_enter('buffers', {
        \   'startmaps': {
        \     '[b': {'start': 'bprevious'},
        \     ']b': {'start': 'bnext'}
        \   },
        \   'maps': {
        \     '[': '<count1>bprevious',
        \     ']': '<count1>bnext'
        \   },
        \   'options': {
        \     'timeout': 1000
        \   }
        \ })

  " curly
  function! SearchCurly(square, curly)
    if a:square == ']'
      silent! call search('^\s*' . a:curly . ';\?$', 'esW')
    elseif a:square == '['
      silent! call search('^\s*' . a:curly . ';\?$', 'besW')
    endif
  endfunction

  call s:tinykeymap_multi_enter('curly', {
        \   'startmaps': {
        \     '[{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("[", "{") | normal! zz'},
        \     ']{': {'start': 'let g:vimrc#last_curly = "{" | call SearchCurly("]", "{") | normal! zz'},
        \     '[}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("[", "}") | normal! zz'},
        \     ']}': {'start': 'let g:vimrc#last_curly = "}" | call SearchCurly("]", "}") | normal! zz'},
        \   },
        \   'maps': {
        \     '[': 'call SearchCurly("[", g:vimrc#last_curly)',
        \     ']': 'call SearchCurly("]", g:vimrc#last_curly)'
        \   },
        \   'options': {
        \     'after': 'normal! zz'
        \   }
        \ })

  " movement
  call tinykeymap#EnterMap('movement', '<Space>.', {'stop': 'mode', 'after': 'normal! zz'})
  call tinykeymap#Map('movement', 'd', "normal! \<C-d>")
  call tinykeymap#Map('movement', 'j', 'normal! j')
  call tinykeymap#Map('movement', 'k', 'normal! k')
  call tinykeymap#Map('movement', 'u', "normal! \<C-u>")

  " quickfix
  call s:tinykeymap_multi_enter('quickfix', {
        \   'startmaps': {
        \     '[q': {'start': 'cprevious | normal! zz'},
        \     ']q': {'start': 'cnext | normal! zz'}
        \   },
        \   'maps': {
        \     '[': '<count1>cprevious',
        \     ']': '<count1>cnext',
        \     'c': {'cmd': 'cclose', 'options': {'exit': 1}}
        \   },
        \   'options': {
        \     'after': 'normal! zz'
        \   }
        \ })
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ultisnips
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:UltiSnipsExpandTrigger = "<C-j>"
let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsJumpForwardTrigger = "<C-j>"
let g:UltiSnipsSnippetDirectories=[$HOME . '/.vim/CustomSnips']

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-buftabline
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
let g:buftabline_plug_max = 15

nmap <Leader>1 <Plug>BufTabLine.Go(1)
nmap <Leader>2 <Plug>BufTabLine.Go(2)
nmap <Leader>3 <Plug>BufTabLine.Go(3)
nmap <Leader>4 <Plug>BufTabLine.Go(4)
nmap <Leader>5 <Plug>BufTabLine.Go(5)
nmap <Leader>6 <Plug>BufTabLine.Go(6)
nmap <Leader>7 <Plug>BufTabLine.Go(7)
nmap <Leader>8 <Plug>BufTabLine.Go(8)
nmap <Leader>9 <Plug>BufTabLine.Go(9)
nmap <Leader>10 <Plug>BufTabLine.Go(10)
nmap <Leader>11 <Plug>BufTabLine.Go(11)
nmap <Leader>12 <Plug>BufTabLine.Go(12)
nmap <Leader>13 <Plug>BufTabLine.Go(13)
nmap <Leader>14 <Plug>BufTabLine.Go(14)
nmap <Leader>15 <Plug>BufTabLine.Go(15)
nmap <Leader>0 <Plug>BufTabLine.Go(-1)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-dirvish
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:dirvish_mode = 2

highlight link DirvishSuffix LineNr

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-easymotion
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_upper = 1

nmap <Plug>(easymotion-prefix)s <Plug>(is-nohl)<Plug>(easymotion-sn)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-sandwhich
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:sandwich#magicchar#f#patterns = [
  \   {
  \     'header' : '\<\%(\h\k*\.\)*\h\k*',
  \     'bra'    : '(\s*',
  \     'ket'    : '\s*)',
  \     'footer' : ''
  \   }
  \ ]
let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
let g:sandwich#recipes += [
  \   {'buns': ['{ ', ' }'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['{']},
  \
  \   {'buns': ['{', '}'], 'kind': ['add', 'replace'], 'action': ['add'],
  \    'motionwise': ['line'], 'command': ["'[+1,']-1normal! >>"]},
  \
  \   {'buns': ['^\s*{$', '^\s*}$'], 'nesting': 1, 'regex': 1, 'linewise': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['{{'], 'command': ["'[,']normal! <<"]},
  \
  \   {'buns': ['[ ', ' ]'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['[']},
  \
  \   {'buns': ['( ', ' )'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['(']},
  \
  \   {'buns': ['< ', ' >'], 'nesting': 1, 'match_syntax': 1,
  \    'kind': ['add', 'replace'], 'action': ['add'], 'input': ['<']},
  \
  \   {'buns': ['{\s*', '\s*}'], 'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['{']},
  \
  \   {'buns': ['\[\s*', '\s*\]'], 'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['[']},
  \
  \   {'buns': ['(\s*', '\s*)'],   'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['(']},
  \
  \   {'buns': ['<\s*', '\s*>'],   'nesting': 1, 'regex': 1,
  \    'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'],
  \    'action': ['delete'], 'input': ['<']}
  \ ]
let g:textobj_sandwich_function_searchlines = 2

nmap s <Nop>
xmap s <Nop>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-startify
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:startify_change_to_dir = 0

nnoremap <Leader>S :Startify<CR>
nnoremap <Leader>SC :SClose<CR>
nnoremap <Leader>SD :SDelete<CR>
nnoremap <Leader>SL :SLoad<CR>
nnoremap <Leader>SS :SSave<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General key maps
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1] =~# '\s'
endfunction

function! s:cmake_format()
  let save_pos = getpos('.')[1:2]
  execute '%!cmake-format %'
  call cursor(save_pos)
endfunction

function! s:last_buf() abort
  if buflisted(0)
    b #
  else
    bp
  endif
endfunction

function! s:safe_close() abort
  call s:last_buf()
  bd #
endfunction

function! s:scratch (command, ...)
  let save_more = &more
  set nomore
  redir => lines
  execute a:command
  redir END
  let &more = save_more
  call feedkeys("\<CR>")
  new +only
  setlocal buftype=nofile bufhidden=hide noswapfile
  put =lines
  if a:0
    execute 'v/' . a:1 . '/d'
  endif
  0
endfunction
command! -nargs=+ Scratch call <SID>scratch(<f-args>)

function! s:compareQuickfixEntries(i1, i2)
  if bufname(a:i1.bufnr) == bufname(a:i2.bufnr)
    return a:i1.lnum == a:i2.lnum ? 0 : (a:i1.lnum < a:i2.lnum ? -1 : 1)
  else
    return bufname(a:i1.bufnr) < bufname(a:i2.bufnr) ? -1 : 1
  endif
endfunction

function! s:sortUniqQFList(...)
  if a:0
    let sortedList = sort(getloclist(), 's:compareQuickfixEntries')
  else
    let sortedList = sort(getqflist(), 's:compareQuickfixEntries')
  endif
  let uniqedList = []
  let last = ''
  for item in sortedList
    let this = bufname(item.bufnr) . "\t" . item.lnum
    if this !=# last
      call add(uniqedList, item)
      let last = this
    endif
  endfor
  if a:0
    call setloclist(uniqedList)
  else
    call setqflist(uniqedList)
  endif
endfunction

function! s:ulti_expandable()
  return !(
        \ col('.') <= 1
        \ || !empty(matchstr(getline('.'), '\%' . (col('.') - 1) . 'c\s'))
        \ || empty(UltiSnips#SnippetsInCurrentScope())
        \ )
endfunction

command! NvConfig edit $HOME/.dotfiles/vim/vimrc

cnoremap <C-a> <Home>
cnoremap <C-b> <Left>
cnoremap <C-d> <S-Right>
cnoremap <C-e> <End>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-s> <S-Left>
inoremap <silent> <expr> <C-Space> coc#refresh()
inoremap <silent> <expr> <Tab>
      \ <SID>ulti_expandable() ? "\<C-r>=UltiSnips#ExpandSnippet()\<CR>" :
      \ pumvisible() ? coc#_select_confirm() :
      \ <SID>check_back_space() ? "\<Tab>" :
      \ coc#refresh()
inoremap jj <Esc>
nnoremap <silent> <Leader><Space> :nohlsearch<CR>:diffupdate<CR>:syntax sync fromstart<CR>:mode<CR>
nnoremap <silent> <Leader><Tab> :call <SID>last_buf()<CR>
nnoremap <silent> <Leader>- :split<CR>
nnoremap <silent> <Leader>/ :vsplit<CR>
nnoremap <silent> <Leader>c :call <SID>safe_close()<CR>
nnoremap <silent> <Leader>q :q<CR>
nnoremap <silent> <Leader>qlc :lclose<CR>zz
nnoremap <silent> <Leader>qlr :lclose<CR>zz:call setloclist(0, [])<CR>
nnoremap <silent> <Leader>qlo :lopen<CR><C-w>pzz
nnoremap <silent> <Leader>qls :call <SID>sortUniqQFList(1)<CR>
nnoremap <silent> <Leader>qc :cclose<CR>zz
nnoremap <silent> <Leader>qr :cclose<CR>zz:call setqflist([])<CR>
nnoremap <silent> <Leader>qs :call <SID>sortUniqQFList()<CR>
nnoremap <silent> <Leader>qo :copen<CR><C-w>pzz
nnoremap <silent> <Leader>Q :call <SID>safe_close()<CR>:q<CR>
nnoremap <silent> <Leader>s :w<CR>
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
vmap < <gv
vmap > >gv

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General autocmds
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup myautocmd
  autocmd!
  autocmd BufNewFile,BufRead .clang-format set filetype=yaml
  autocmd BufWritePost ~/.dotfiles/vim/vimrc ++nested source ~/.dotfiles/vim/vimrc
  autocmd FileType c,cpp,h,hpp,java,snippets setlocal expandtab tabstop=4 shiftwidth=4
  autocmd FileType cmake nnoremap <buffer> <silent> <Space>f :w<CR>:call <SID>cmake_format()<CR>
  autocmd FileType help nnoremap <buffer> <silent> q :q<CR>
  autocmd FileType json syntax match Comment +\/\/.\+$+
  autocmd FileType man nnoremap <buffer> <silent> q :call <SID>safe_close()<CR>:q<CR>
  autocmd InsertEnter,WinLeave * set nocursorline
  autocmd InsertLeave,WinEnter * set cursorline
augroup end
